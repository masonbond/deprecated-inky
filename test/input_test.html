<!DOCTYPE html>
<html>
<head>
<script src="../src/utils.js"></script>
<script src="../src/inky.js"></script>
<style>
body {
	background: #323232;
	color: #dddddd;
	font-family: sans-serif;
	font-size: 11pt;
}

.test {
	font-family: monospace;
	position: relative;
	width: 300px;
	height: 300px;
	background: black;
}

#smear {
background: #222;
border-radius: 50%;
width: 400px;
height: 400px;
}

.test .stick-cap {
	color: #f00;
	background: #fff;
	border-radius: 50%;
	width: 60%;
	height: 60%;
	margin: 20% 0 0 20%;
	position: absolute;
}

.stick-cap .stick-cap {
	margin: 10% 0 0 10%;
	width: 80%;
	height: 80%;
	background: linear-gradient(-150deg, rgba(196,196,209,1) 32%,rgba(254,252,234,1) 100%);
	box-shadow: none;
	opacity: 1;
}

</style>
</head>
<body>
input test
<div id="test" class="test">asdf</div>g<div id="test2" class="test">d</div>buns
<div id="smear" class="test"><div class="stick-cap"></div></div>
<input type="text" id="text1"><input type="text" id="text2">

<script>
console.log(IN.version);
console.log(IN);

var testElement = document.getElementById("test");
var testElement2 = document.getElementById("test2");
var smearElement = document.getElementById('smear');

var input2 = new IN.Dispatcher({
	element: testElement2,
	pollRate: 40, 
	allowDefaultKeyboardEvents: true,
	allowFocusOnHover: true,
	analogDeadZone: 0.5,
	analogNormalized: true,
	orientationXYNormalized: false
});

var smear = new IN.TouchArea({
	name: "Smearscreen",
	element: smearElement,
	floatOrigin: true,
	snap: true,
	deadZone: 0.25,
	threshold: 0.00001,
	normalized: true
});

var smearCap = smearElement.childNodes[0];

console.log("smear", smear);

var t2 = {val:0,times:[]};

setTimeout(function() {	document.getElementById('test2').innerHTML = 'CALIBRATED ROTATION';	input2.calibratePosition(); }, 000);

var orientControl = new IN.Control({
	move: function(e) {

		if (e.component === IN.MOTION_ACCELERATION_X) e.target.x += Math.abs(e.move.v);
		if (e.component === IN.MOTION_ACCELERATION_Y) e.target.y += Math.abs(e.move.v);
		if (e.component === IN.MOTION_ACCELERATION_Z) e.target.z += Math.abs(e.move.v);
		if (e.component === IN.MOTION_ACCELERATION_MAGNITUDE) e.target.m = Math.abs(e.move.v);

		if (e.move.v === 0) ++e.target.n;

		if (e.target.x > e.target.y &&
			e.target.x > e.target.z) {
			testElement.innerHTML = "a: 100%\nY: " + parseInt(100 * e.target.y / e.target.x, 10) + "%\nZ: " + parseInt(100 * e.target.z / e.target.x, 10) + "%";
		} else if (e.target.y > e.target.z &&
		    	 e.target.y > e.target.x) {
			testElement.innerHTML = "a: " + parseInt(100 * e.target.x / e.target.y, 10) + "%\nY: 100%\nZ: " + parseInt(100 * e.target.z / e.target.y, 10) + "%";
		} else if (e.target.z > e.target.y &&
			e.target.z > e.target.x) {
			testElement.innerHTML = "a: " + parseInt(100 * e.target.x / e.target.z, 10) + "%\nY: " + parseInt(100 * e.target.y / e.target.z, 10) + "\nZ: 100%";
		}


		//if (e.component === IN.MOTION_ACCELERATION_MAGNITUDE) testElement.innerHTML = e.target.n + "<br>X: " + e.target.x + "<br>Y: " + e.target.y + "<br>Z: " + e.target.z + "<br><br>" + e.target.max;
	}
});

var orientBinding = new input2.bind({
	control: orientControl,
	component: [IN.MOTION_ACCELERATION_X, IN.MOTION_ACCELERATION_Y, IN.MOTION_ACCELERATION_Z, IN.MOTION_ACCELERATION_MAGNITUDE],//[IN.MOTION_ORIENTATION_X, IN.MOTION_ORIENTATION_Y],
	target: { x: 0, y: 0, z: 0, m: 0, n: 0, max: 0 }
});

function ffff(e) {
	if (e.component === IN.MOTION_ORIENTATION_X) e.target.x = e.move.v;
	if (e.component === IN.MOTION_ORIENTATION_Y) e.target.y = e.move.v;
	if (e.component === IN.MOTION_ORIENTATION_Z) e.target.z = e.move.v;
	if (e.component === IN.MOTION_ORIENTATION_MAGNITUDE) e.target.m = e.move.v;

	if (e.move.v === 0) ++e.target.n;

	document.getElementById('test2').innerHTML = e.target.n + "<br>X: " + e.target.x + "<br>Y: " + e.target.y + "<br>Z: " + e.target.z + "<br><br>" + IN.async[IN.MOTION_ORIENTATION_Z];
};

var rotationControl = new IN.Control({
	move: ffff
});

var rotationBinding = new input2.bind({
	control: rotationControl,
	component: [IN.MOTION_ORIENTATION_X, IN.MOTION_ORIENTATION_Y, IN.MOTION_ORIENTATION_Z],//[IN.MOTION_ORIENTATION_X, IN.MOTION_ORIENTATION_Y],
	target: { x: 0, y: 0, z: 0, m: 0, n: 0}
});


var c2 = new IN.Control({
	press: function(e){
		console.log("2 press");
	},
	hold: function(e){
		console.log("2 hold");
	},
	release: function(e){
		console.log("2- pressed and released", ++this.target.val, "times");
		console.log(e);
	},
	move: function(e){
		console.log("2 MVOE!!!!!!!!!", e.component, e.move);
	}
});

function poop(e){
	input2.calibratePosition();

	if (e.component === smear.RADIAL_X) e.target.x = e.move.v;
	else if (e.component === smear.RADIAL_Y) e.target.y = e.move.v;
	else if (e.component === smear.PRESSURE) e.target.p = e.move.v;

	smearCap.innerHTML = e.type + "<br>X: " + e.target.x + "<br>Y: " + e.target.y + "<br>pressure: " + e.target.p;
	console.log(e.component, e.move, smearCap.innerHTML);

	var rect = smearElement.getBoundingClientRect();
	smearCap.style.top = (e.target.y * (rect.bottom - rect.top) / 2) + 'px';
	smearCap.style.left = (e.target.x * (rect.right - rect.left) / 2) + 'px';
}

var c = new IN.Control({
	move: poop,
	press: function() {
		console.log(">>> Press POOP");
	},
	release: function() {
		console.log(">>> Release POOP");
	}
});

var binding = input2.bind({
	control: c,
	target: { x: 0, y: 0 },
	component: [smear.RADIAL_X, smear.RADIAL_Y, smear.PRESSURE]
});

var binding2 = input2.bind({
	control: c2,
	target: t2,
	moveArgs: {x: -1},  
	component: [IN.KEY_SPACE, IN.GAMEPAD_0_BUTTON_0, IN.GAMEPAD_LEFT_TRIGGER, IN.MOUSE_LEFT_BUTTON, IN.GAMEPAD_LEFT_STICK_RADIAL_X, IN.GAMEPAD_LEFT_STICK_RADIAL_Y]
	//component: [IN.KEY_SPACE, IN.GAMEPAD_0_BUTTON_0, IN.GAMEPAD_LEFT_TRIGGER, IN.MOUSE_LEFT_BUTTON, IN.GAMEPAD_LEFT_STICK_X, IN.GAMEPAD_LEFT_STICK_Y]
});//*/


     
console.log("binding2", binding2, c);

testElement.addEventListener("click", function(e) {
	input.requestPointerLock(function(e) {
		console.log("entering pointurd lock");
		setTimeout(function(){
			input.exitPointerLock(function(e) {
				console.log("exiting pointer lock - this callback set at time of exit request");
			});
		}, 5000);
	},
	function(e) {
		console.log("exiting pointer lock - this callback set at time of lock request");
	});

});
//*/
//setInterval(function(){console.log(IN.async);},1000);

</script>
</body>
</html>
